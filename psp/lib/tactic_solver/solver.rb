module TacticSolver
  class Solver
    include Bud
    include TacticProtocol

    state do
      # These are the truths that we know
      # We know WHAT sort of truth they are
      # We know WHO the truth was made for
      # and we know the TRUTH itself
      table :truths, [:what, :provider, :user_info, :signpost] => [:truth, :ttl_state]

      # These are the truths that are subscribed to
      # We know WHAT truth is needed
      # and WHO needs the truth
      table :truth_subscribers, [:what, :who, :signpost] => [:user_info, :who_name]

      # Truths that can now be satisfied
      # We know WHO needs WHAT and for WHAT user,
      # and the TRUTH needed
      scratch :satisfiable_truth_needs, [:who, :what, :user_info, :signpost] => [:truth]

      # For adapting truths to serve to anyone
      scratch :adapted_provided_truths, [:what, :original_what, :provider, :user_info, :signpost] => [:truth]

      # Temp for adding ttl state to new truths. Ideally this would only be
      # a in block temp collection, but the temp collections do not support
      # schemas.
      scratch :storable_truths, [:what, :provider, :user_info, :signpost] => [:truth, :ttl_state]

      # Garbage collection timer
      periodic :garbage_collection_timer, 10

      # truth to be redistributed
      scratch :redistributable_truths, [:what, :provider, :user_info, :signpost] => [:truth, :ttl]

      # FIXME: Find better way to deliver this truth, than through a channel...
      # :(
      channel :provide_truth_from_external
    end

    # Remove truths that are no longer valid
    bloom :garbage_collection do
      truths <- (garbage_collection_timer*truths).pairs do |g,t|
        t unless ttl_is_valid? t
      end
    end

    # Unsubscribe tactics that terminate
    bloom :remove_leavers do
      remove_subscriptions_scratch <= remove_subscriptions.payloads
      truth_subscribers <- (truth_subscribers*remove_subscriptions_scratch).
          lefts(:who => :who)
    end

    # Exchange truths with tactics
    bloom :tactic_comms do
      need_truth_scratch <= need_truth.payloads
      observe_truth_scratch <= observe_truth.payloads

      # A tactic subscribes to a truth so it receives new truths
      # as they come in.
      truth_subscribers <+- need_truth_scratch
      # A tactic can also just become an observer.
      # This will not cause a new truth to be generated
      truth_subscribers <+- observe_truth_scratch

      # Let's see if we can satisfy the truths directly from our truth cache
      satisfiable_truth_needs <= (truths*need_truth_scratch).
          pairs(:what => :what) {|t, nt| 
        # 1) Check that the user is allowed to see the truth
        # 2) Validate that the truth was generated in the right place
        if ((t.user_info == "GLOBAL" or t.user_info == nt.user_info) and
              ttl_is_valid? t) and (nt.signpost == "ANY" or nt.signpost == t.signpost) then
          # Create a truth without the TTL state
          truth = [t.what, t.provider, t.user_info, t.signpost, t.truth]
          # Pass the truth back to the user
          [nt.who, t.what, nt.user_info, t.signpost, truth]
        end
      }
      needed_truth <~ satisfiable_truth_needs {|stn| [stn.who, stn.truth]}

      # Find needs that we cannot satisfy, and register them
      temp :dev_null_1 <= need_truth_scratch do |nt|
        unless satisfiable_truth_needs.exists? {|s|
          s.what == nt.what and 
          (s.user_info == nt.user_info or s.user_info == "GLOBAL") and
          (nt.signpost == "ANY" or s.signpost == nt.signpost)
        } then

          # There is no satisfiable truth need.
          # This means that the truth needs to be generated by someone.
          # If the signpost parameter is set to ANY or is the same as our own
          # node name, then we generate it locally. Otherwise, have a remote 
          # signpost node evaluate it.
          if (nt.signpost == @_name or nt.signpost == "ANY") then
            @_thread_pool.explore_truth_space_for nt.what, nt.user_info
          else
            @_communication_center.remote_resolve nt.what, nt.user_info, nt.signpost
          end
        end
      end
      
      # Distribute truths to the network
      redistributable_truths <= provide_truth.payloads
      temp :dev_null_2 <= redistributable_truths do |t|
        @_communication_center.distribute_truths [[t.what, t.provider, t.user_info, t.signpost, t.truth, t.ttl]]
      end

      provide_truth_scratch <= provide_truth_from_external.payloads
      provide_truth_scratch <= provide_truth.payloads
      # We received a new truth. Now we need to create
      # a ttl_state session for this truth so we can convert
      # it into a truth ready for the truth table.
      storable_truths <= provide_truth_scratch do |t|
        ttl = t.ttl
        ttl_state = create_ttl_state ttl
        [t.what, t.provider, t.user_info, t.signpost, t.truth, ttl_state] if ttl > 0
      end
      truths <+- storable_truths

      needed_truth <~ (provide_truth_scratch*truth_subscribers).
          pairs(:what => :what) do |p,t|
        if (p.user_info == "GLOBAL" or p.user_info == t.user_info) then
          [t.who, [p.what, p.provider, p.user_info, p.signpost, p.truth]]
        end
      end

      # If a daemon is subscribing to resource from ANY domain
      # then we need an alternative approach.
      # Also realise that the daemon gets the truth REGARDLESS
      # of the user info!
      adapted_provided_truths <= provide_truth_scratch do |t|
        # Get the resource part of the what
        t.what =~ /([[:graph:]]*)@.*/
        alternative_what = "#{$1}@ANY"
        [alternative_what, t.what, t.provider, t.user_info, t.signpost, t.truth]
      end
      needed_truth <~ (adapted_provided_truths*truth_subscribers).
          pairs(:what => :what) do |p,t|
        if (p.signpost == t.signpost or t.signpost == "ANY") then
          [t.who, [p.original_what, p.provider, p.user_info, p.signpost, p.truth]]
        end
      end
    end

    def initialize node_name = "default", options = {}
      @_config = Config.new
      @_logger = Logger.new @_config
      @_name = @_config.signpost_client

      super options
      self.run_bg

      add_initial_truths

      # Pool for tactics
      @_thread_pool = TacticPool.new @_name, ip_port, @_logger
      
      # For communication with other signposts
      @_communication_center = CommunicationCentre.new self, @_config, @_logger
    end

    def add_external_truth truth
      sync_do {provide_truth_from_external <~ [[ip_port, truth]]}
    end

    def resolve what, user_info, signpost = "ANY"
      options = {
        :what => what, 
        :solver => ip_port, 
        :user_info => user_info,
        :signpost => signpost
      }
      question = Question.new options do |truths|
        puts "QUESTION #{what}"
        truths.to_a.each do |truth|
          truth_name, who, user_info, signpost, answer = truth
          puts "ANSWER:"
          puts "\ttruth: #{truth_name}"
          puts "\tprovider: #{who}"
          puts "\tuser_info: #{user_info}"
          puts "\tsignpost: #{signpost}"
          if answer.class == Array then
            puts "\tdata: [#{answer.join(", ")}]"
          else
            puts "\tdata: [#{answer}]"
          end
        end
      end
    end

    def tactics
      @_thread_pool.tactics
    end

    def signposts
      @_communication_center.known_signposts
    end

    # This method is called by the communication agent to
    # find the truths that are ours that we hold.
    # It also readies them for export.
    def exportable_truths
      # Now that we are doing broadcast, we want to export all truths
      exports = self.truths.to_a
      # # We only export truths that are from this signpost
      # exports = self.truths.to_a.select do |t|
      #   t[3] == @_name
      # end
      # Turns TTL from a timestamp, back into a regular TTL
      results = exports.map do |t|
        ttl_state = t[-1]
        ttl = ttl_state[:expires] - Time.now.to_i
        # If I change t, then somehow I do affect the original copy stored in
        # the truth table on this node. Hence the ugly buildup of an array
        # below.
        # This is most peculiar as "select" above should have generated a new
        # array that I could change and do with as I please, but somehow it
        # does still reference the original elements.
        [t[0], t[1], t[2], t[3], t[4], ttl]
      end
      results
    end

  private
    # TODO: Shouldn't be needed in this form
    def add_initial_truths
      async_do {
        truths <+- [
          ["web_auth_url@#{@_name}", 
           "global_truth",
           "GLOBAL", 
           @_name,
           "http://localhost:8080/requests",
           create_ttl_state(1_000_000)],
          ["local_signpost_domain@#{@_name}", 
           "global_truth",
           "GLOBAL", 
           @_name,
           @_config.signpost_domain,
           create_ttl_state(1_000_000)]
        ]
      }
    end

    def ttl_is_valid? truth
      return false if truth.ttl_state == :non_cacheable
      ttl_state = truth.ttl_state
      ttl_state[:expires] > Time.now.to_i
    end

    def create_ttl_state ttl
      if ttl == 0 then
        :non_cacheable
      else
        {
          :ttl => ttl,
          :expires => Time.now.to_i + ttl
        }
      end
    end
  end
end
